
---
title: "Education Expenditure (% GDP) and Refugees: Cross-Country Panel Analysis"
author: "Auto-generated by ChatGPT"
date: "`r format(Sys.Date())`"
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    number_sections: true
  pdf_document: default
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
set.seed(123)
```

# 1. Purpose & Roadmap

**Goal.** Quantify how refugee inflows hosted by a country relate to **education expenditure (% of GDP)**, controlling for macro covariates, and compare statistical and ML models to select a best-performing specification for inference and prediction.

**Dataset.** `/mnt/data/all_gdp_refugees.csv` with key columns:
- `country`, `iso2c`, `iso3c`, `year`
- `edu_exp_gdp` (education expenditure as % of GDP) — *target variable*
- Macros: `gdp_per_capita`, `gov_exp_gdp`, `unemployment_rate`, `inflation_rate`, `population`, `urban_pop_percent` (if present)
- Displacement stats (UNHCR-style): `HST` (refugees hosted), `Refugees` (origin refugees), `Asylum.Seekers`, `IDPs`, `Returned.Refugees`, `Returned.IDPs`, `Stateless`

**Perspective.** We focus on **host-country** burden, using `HST` as the primary exposure. We also report **origin-country** correlations using `Refugees` for completeness.

**Plan.**
1. Data checks, cleaning, and feature engineering.
2. EDA: trends, distribution, missingness, and bivariate patterns.
3. Baseline models (pooled OLS; FE TWFE; RE) with robust SE.
4. Dynamic & robust specifications (lags, Driscoll–Kraay; Arellano–Bond).
5. Predictive ML (Random Forest, XGBoost) with grouped CV by country.
6. Model selection, diagnostics, and interpretation.
7. Sensitivity: winsorization, income-group heterogeneity.
8. Export tables and figures.

# 2. Libraries & Data Import

```{r libraries}
packages <- c(
  "tidyverse","janitor","readr","skimr","naniar","GGally","scales",
  "broom","modelsummary","gt",
  "fixest","plm","sandwich","lmtest","clubSandwich",
  "rsample","parsnip","recipes","workflows","yardstick","tune","dials",
  "ranger","xgboost","vip","pdp"
)
to_install <- packages[!packages %in% installed.packages()[,"Package"]]
if(length(to_install)) install.packages(to_install, dependencies = TRUE)

invisible(lapply(packages, library, character.only = TRUE))
```

```{r import}
data_path <- "/mnt/data/all_gdp_refugees.csv"
df_raw <- readr::read_csv(data_path, show_col_types = FALSE) %>%
  janitor::clean_names()

glimpse(df_raw)
skimr::skim(df_raw)
```

# 3. Data Cleaning & Feature Engineering

```{r cleaning}
df <- df_raw %>%
  # Keep plausible years
  filter(year >= 1990, year <= 2023) %>%
  # Standardize country code and ensure numeric types
  mutate(
    country = as.factor(country),
    iso3c = as.factor(iso3c),
    year = as.integer(year),
    edu_exp_gdp = as.numeric(edu_exp_gdp),
    gdp_per_capita = as.numeric(gdp_per_capita),
    gov_exp_gdp = as.numeric(gov_exp_gdp),
    unemployment_rate = suppressWarnings(as.numeric(unemployment_rate)),
    inflation_rate = suppressWarnings(as.numeric(inflation_rate)),
    population = as.numeric(population),
    hst = as.numeric(HST),
    refugees_origin = as.numeric(Refugees),
    asylum_seekers = as.numeric(Asylum.Seekers),
    idps = as.numeric(IDPs)
  ) %>%
  # Derived features
  mutate(
    hst_per_1k = 1000 * hst / population,
    refugees_origin_per_1k = 1000 * refugees_origin / population,
    asylum_seekers_per_1k = 1000 * asylum_seekers / population,
    idps_per_1k = 1000 * idps / population,
    gdp_pc_log = log1p(gdp_per_capita),
    pop_log = log1p(population),
    hst_log = log1p(hst),
    # Lags for dynamic effects (by country)
    hst_per_1k_l1 = dplyr::lag(hst_per_1k, 1),
    hst_per_1k_l2 = dplyr::lag(hst_per_1k, 2),
    edu_exp_gdp_l1 = dplyr::lag(edu_exp_gdp, 1)
  ) %>%
  group_by(country) %>%
  arrange(year, .by_group = TRUE) %>%
  ungroup()

# Check missingness of key fields
miss_tbl <- naniar::miss_var_summary(df %>% select(country, year, edu_exp_gdp, gdp_per_capita, gov_exp_gdp, population, hst, hst_per_1k))
miss_tbl
```

> **Note.** `HST` appears to represent *refugees hosted* (e.g., Uganda ~2.6M in 2023). We therefore use `hst` / `hst_per_1k` as host-burden measures. If `HST` is unavailable for some rows, we will drop those rows for host-side specifications and keep them for origin-side robustness using `refugees_origin`.

# 4. Exploratory Data Analysis (EDA)

```{r eda-1}
# Coverage by year & country
coverage_year <- df %>% group_by(year) %>% summarize(n=n(), n_hst=sum(!is.na(hst)), n_edu=sum(!is.na(edu_exp_gdp)))
coverage_country <- df %>% group_by(country) %>% summarize(n=n(), n_hst=sum(!is.na(hst)), n_edu=sum(!is.na(edu_exp_gdp)))

# Basic plots
ggplot(df, aes(x = year, y = edu_exp_gdp, group = country)) +
  geom_line(alpha = 0.15) +
  labs(title="Education Expenditure (% of GDP) over Time", y="% of GDP", x="Year")

ggplot(df, aes(x = hst_per_1k, y = edu_exp_gdp)) +
  geom_point(alpha = 0.3) +
  geom_smooth(method="loess", se=FALSE) +
  scale_x_continuous(labels = scales::comma) +
  labs(title="Bivariate: Refugees Hosted per 1k vs Education Expenditure (% GDP)")

ggplot(df, aes(x = gdp_pc_log, y = edu_exp_gdp)) +
  geom_point(alpha = 0.3) +
  geom_smooth(method="loess", se=FALSE) +
  labs(title="Bivariate: log(GDP per capita) vs Education Expenditure (% GDP)")

GGally::ggpairs(df %>% select(edu_exp_gdp, hst_per_1k, gdp_pc_log, gov_exp_gdp, unemployment_rate, inflation_rate) %>% drop_na())
```

```{r eda-2}
# Outliers & leverage candidates
q <- quantile(df$hst_per_1k, probs=c(0.99), na.rm = TRUE)
df %>% filter(!is.na(hst_per_1k) & hst_per_1k >= q) %>%
  arrange(desc(hst_per_1k)) %>%
  select(country, year, hst_per_1k, hst, population) %>% head(20)
```

# 5. Baseline Statistical Models

## 5.1 Pooled OLS (benchmark, no FE)

```{r m-ols}
m_ols <- lm(edu_exp_gdp ~ hst_per_1k + gdp_pc_log + gov_exp_gdp + unemployment_rate + inflation_rate + pop_log,
            data = df %>% drop_na(edu_exp_gdp, hst_per_1k, gdp_pc_log, gov_exp_gdp, population))

ols_robust <- lmtest::coeftest(m_ols, vcov = sandwich::vcovHC(m_ols, type = "HC1"))
ols_robust
```

## 5.2 Two-Way Fixed Effects (country & year)

```{r m-fe}
# fixest syntax: outcome ~ regressors | fixed-effects
m_fe <- fixest::feols(
  edu_exp_gdp ~ hst_per_1k + gdp_pc_log + gov_exp_gdp + unemployment_rate + inflation_rate | country + year,
  data = df
)

# Clustered SE by country; also Driscoll–Kraay
m_fe_clu <- fixest::coeftable(m_fe, vcov = ~ country)
m_fe_dk  <- fixest::coeftable(m_fe, vcov = fixest::vcovDC(m_fe, type = "HC1"))

modelsummary::modelsummary(
  list("Pooled OLS"=m_ols, "TWFE"=m_fe),
  vcov = list(sandwich::vcovHC(m_ols, type="HC1"), fixest::vcovDC(m_fe, type="HC1")),
  stars = TRUE, gof_omit = "IC|R2_within|R2_pseudo"
)
```

## 5.3 Random Effects & Hausman Test

```{r m-re}
pdata <- plm::pdata.frame(df %>% drop_na(edu_exp_gdp, hst_per_1k, gdp_pc_log, gov_exp_gdp), index = c("country","year"))
m_re <- plm::plm(edu_exp_gdp ~ hst_per_1k + gdp_pc_log + gov_exp_gdp + unemployment_rate + inflation_rate + pop_log, 
                 data = pdata, model = "random")

m_fe_plm <- plm::plm(edu_exp_gdp ~ hst_per_1k + gdp_pc_log + gov_exp_gdp + unemployment_rate + inflation_rate + pop_log, 
                     data = pdata, model = "within", effect = "twoways")

haus <- plm::phtest(m_fe_plm, m_re)
haus
```

# 6. Dynamic & Robust Specifications

## 6.1 TWFE with lags

```{r m-lags}
m_lag <- fixest::feols(
  edu_exp_gdp ~ hst_per_1k + hst_per_1k_l1 + hst_per_1k_l2 + gdp_pc_log + gov_exp_gdp + unemployment_rate + inflation_rate | country + year,
  data = df
)
summary(m_lag, vcov = fixest::vcovDC(m_lag, type = "HC1"))
```

## 6.2 Driscoll–Kraay SE

```{r m-dk}
m_dk <- fixest::feols(
  edu_exp_gdp ~ hst_per_1k + gdp_pc_log + gov_exp_gdp + unemployment_rate + inflation_rate | country + year,
  data = df
)
summary(m_dk, vcov = fixest::vcovDC(m_dk, type = "HC1"))
```

## 6.3 Arellano–Bond (Dynamic Panel with lagged DV)

```{r m-ab}
# Requires no missing in the variables used; keep balanced subset
df_bal <- df %>%
  select(country, year, edu_exp_gdp, hst_per_1k, gdp_pc_log, gov_exp_gdp, unemployment_rate, inflation_rate) %>%
  group_by(country) %>% filter(n() >= 5) %>% ungroup() %>% drop_na()

pdata_bal <- plm::pdata.frame(df_bal, index = c("country","year"))

m_ab <- plm::pgmm(
  formula = edu_exp_gdp ~ lag(edu_exp_gdp, 1) + hst_per_1k + gdp_pc_log + gov_exp_gdp + unemployment_rate + inflation_rate |
            lag(edu_exp_gdp, 2:4) + lag(hst_per_1k, 2:4),
  data = pdata_bal, effect = "individual", model = "twosteps", transformation = "d"
)
summary(m_ab)
```

# 7. Predictive ML Models (tidymodels)

We build models to predict `edu_exp_gdp` and compare out-of-sample performance. Use **grouped v-fold CV by country** to avoid leakage across countries.

```{r ml-prep}
ml_df <- df %>%
  select(country, year, edu_exp_gdp, hst_per_1k, gdp_pc_log, gov_exp_gdp, unemployment_rate, inflation_rate, pop_log, asylum_seekers_per_1k, idps_per_1k) %>%
  drop_na()

# Grouped CV by country
set.seed(123)
folds <- rsample::group_vfold_cv(ml_df, group = country, v = 5)

rec <- recipes::recipe(edu_exp_gdp ~ ., data = ml_df) %>%
  update_role(country, year, new_role = "ID") %>%
  step_zv(all_predictors()) %>%
  step_impute_median(all_numeric_predictors()) %>%
  step_normalize(all_numeric_predictors())

wf_rf <- workflows::workflow() %>%
  add_model(parsnip::rand_forest(mtry = tune(), trees = 1000, min_n = tune()) %>%
              parsnip::set_engine("ranger") %>%
              parsnip::set_mode("regression")) %>%
  add_recipe(rec)

wf_xgb <- workflows::workflow() %>%
  add_model(parsnip::boost_tree(trees = 2000, learn_rate = tune(), tree_depth = tune(), mtry = tune(), loss_reduction = tune(), min_n = tune()) %>%
              parsnip::set_engine("xgboost") %>%
              parsnip::set_mode("regression")) %>%
  add_recipe(rec)

grid_rf <- dials::grid_latin_hypercube(
  dials::mtry(range = c(3, 8)),
  dials::min_n(),
  size = 15
)

grid_xgb <- dials::grid_latin_hypercube(
  dials::learn_rate(), dials::tree_depth(), dials::mtry(range=c(3,8)), dials::loss_reduction(), dials::min_n(),
  size = 25
)
```

```{r ml-tune, cache=TRUE}
set.seed(123)
tune_rf <- tune::tune_grid(wf_rf, resamples = folds, grid = grid_rf, metrics = yardstick::metric_set(rmse, mae, rsq))
tune_xgb <- tune::tune_grid(wf_xgb, resamples = folds, grid = grid_xgb, metrics = yardstick::metric_set(rmse, mae, rsq))

rf_best <- select_best(tune_rf, "rmse")
xgb_best <- select_best(tune_xgb, "rmse")

rf_final <- finalize_workflow(wf_rf, rf_best) %>% fit(ml_df)
xgb_final <- finalize_workflow(wf_xgb, xgb_best) %>% fit(ml_df)

collect_metrics(tune_rf) %>% arrange(mean) %>% head()
collect_metrics(tune_xgb) %>% arrange(mean) %>% head()
```

```{r ml-interpret}
# Variable importance and partial dependence (on finalized models)
vip::vip(rf_final$fit$fit, num_features = 10)

# For xgboost, extract underlying model
# Note: vip may need different method; using generic vip(workflow) is fine in recent versions.
# PDP for hst_per_1k
pdp::partial(object = rf_final$fit$fit, pred.var = "hst_per_1k", grid.resolution = 20) %>%
  autoplot() + labs(title="Partial Dependence: HST per 1k")
```

# 8. Model Comparison & Selection

```{r model-compare}
# Summaries for inference models with robust SE
tab <- modelsummary::modelsummary(
  list(
    "OLS" = m_ols,
    "TWFE" = m_fe,
    "TWFE + Lags" = m_lag
  ),
  vcov = list(
    sandwich::vcovHC(m_ols, type="HC1"),
    fixest::vcovDC(m_fe, type="HC1"),
    fixest::vcovDC(m_lag, type="HC1")
  ),
  statistic = "({std.error}){stars}",
  gof_map = tribble(
    ~raw, ~clean, ~fmt,
    "nobs","N","{:}",
    "r.squared","R2","{:.3f}",
    "adj.r.squared","Adj. R2","{:.3f}"
  )
)
tab
```

# 9. Sensitivity & Heterogeneity

```{r sensitivity}
# Winsorize extreme exposures at 99th percentile
p99 <- quantile(df$hst_per_1k, 0.99, na.rm = TRUE)
df_w <- df %>% mutate(hst_per_1k_w = pmin(hst_per_1k, p99))

m_w <- fixest::feols(
  edu_exp_gdp ~ hst_per_1k_w + gdp_pc_log + gov_exp_gdp + unemployment_rate + inflation_rate | country + year,
  data = df_w
)
summary(m_w, vcov = fixest::vcovDC(m_w, type="HC1"))

# Income-group heterogeneity (approximate via GDP per capita terciles)
cuts <- quantile(df$gdp_per_capita, probs=c(1/3, 2/3), na.rm = TRUE)
df_h <- df %>%
  mutate(income_tercile = case_when(
    gdp_per_capita <= cuts[1] ~ "Low",
    gdp_per_capita <= cuts[2] ~ "Mid",
    TRUE ~ "High"
  ))

m_inter <- fixest::feols(
  edu_exp_gdp ~ hst_per_1k * income_tercile + gdp_pc_log + gov_exp_gdp + unemployment_rate + inflation_rate | country + year,
  data = df_h
)
summary(m_inter, vcov = fixest::vcovDC(m_inter, type="HC1"))
```

# 10. Origin-Side Robustness (optional)

```{r origin-side}
m_origin <- fixest::feols(
  edu_exp_gdp ~ refugees_origin_per_1k + gdp_pc_log + gov_exp_gdp + unemployment_rate + inflation_rate | country + year,
  data = df
)
summary(m_origin, vcov = fixest::vcovDC(m_origin, type="HC1"))
```

# 11. Key Findings & Interpretation (template)

- **Sign of host-burden coefficient (`hst_per_1k`)**: interpret as the percent-point change in education expenditure % of GDP for a 1 refugee per 1,000 population increase.
- **Economic magnitude**: compare implied shifts against WB–UNHCR benchmarks (typical costs <~5% of education budgets), considering donor aid.
- **Dynamic effects**: if lags are significant, discuss timing of budget responses.
- **Heterogeneity**: low-income hosts may exhibit stronger responses due to tighter fiscal space.
- **Predictive performance**: report best RMSE/MAE model (RF/XGB) and interpret variable importance carefully.

# 12. Reproducibility

- All code is contained herein. Set a random seed for reproducibility of resampling/tuning.
- Document package versions if publishing (session info below).

```{r session-info}
sessionInfo()
```
